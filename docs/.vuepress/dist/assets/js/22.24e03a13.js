(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{386:function(t,a,r){"use strict";r.r(a);var v=r(45),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"数组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),r("p",[t._v("存储：根据数组大小分配内存，占据一块连续的内存并按照顺序存储数据，")]),t._v(" "),r("h2",{attrs:{id:"创建方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建方法"}},[t._v("#")]),t._v(" 创建方法")]),t._v(" "),r("ol",[r("li",[t._v("使用Array构造函数")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("let arr = new Array(2)\n")])])]),r("ol",{attrs:{start:"2"}},[r("li",[t._v("数组字面量")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("let arr = [1, 2]\n")])])]),r("p",[t._v("注：使用此方法定义的数组不会调用Array的构造函数 (???)")]),t._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[t._v("Array.from( arrayLike, function,  )\n将类数组结构转化成数组，如 字符串、Map、Set、generator、 arguments参数、带类数组格式的对象")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("let obj = {\n  0:1,\n  1:2,\n  2:3,\n  3:4,\n  length: 4\n}\n\nArray.from(obj); // [1,2,3,4]\n")])])]),r("p",[t._v("参考： "),r("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/array#Array-from",target:"_blank",rel:"noopener noreferrer"}},[t._v("ES6 Array.from( )"),r("OutboundLink")],1)]),t._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[t._v("Array.of()\n将一组数值转化成数组。为了弥补数组的缺点")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("Array(3); // [undefined, undefined, undefined]\nArray.of(3); //[3]\n")])])]),r("h2",{attrs:{id:"数组空位"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数组空位"}},[t._v("#")]),t._v(" 数组空位")]),t._v(" "),r("p",[t._v("由于可能存在不同函数对空位的处理不同，因此建议直接赋值undefined")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('const arr = [1,,,2];\n\narr.join("*"); // "1***2"\narr.map(()=>6); \n')])])]),r("h2",{attrs:{id:"检测数组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#检测数组"}},[t._v("#")]),t._v(" 检测数组")]),t._v(" "),r("ol",[r("li",[t._v("instanceof")]),t._v(" "),r("li",[t._v("Array.isArray()")])]),t._v(" "),r("h2",{attrs:{id:"数组方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数组方法"}},[t._v("#")]),t._v(" 数组方法")]),t._v(" "),r("ol",[r("li",[t._v("迭代器方法")])]),t._v(" "),r("ul",[r("li",[t._v("keys()")]),t._v(" "),r("li",[t._v("values()")]),t._v(" "),r("li",[t._v("entries()")])]),t._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[t._v("复制方法")])]),t._v(" "),r("ul",[r("li",[t._v("fill()")])]),t._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[t._v("填充方法")])]),t._v(" "),r("ul",[r("li",[t._v("copyWithin()")])]),t._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[t._v("转换方法")])]),t._v(" "),r("ul",[r("li",[t._v("toString()")]),t._v(" "),r("li",[t._v("valueOf()")]),t._v(" "),r("li",[t._v("toLocalString()")])]),t._v(" "),r("ol",{attrs:{start:"5"}},[r("li",[t._v("栈方法")])]),t._v(" "),r("ul",[r("li",[t._v("push()")]),t._v(" "),r("li",[t._v("pop()")])]),t._v(" "),r("ol",{attrs:{start:"6"}},[r("li",[t._v("队列方法")])]),t._v(" "),r("ul",[r("li",[t._v("unshift()")]),t._v(" "),r("li",[t._v("shift()")])]),t._v(" "),r("ol",{attrs:{start:"7"}},[r("li",[t._v("排序方法")])]),t._v(" "),r("ul",[r("li",[t._v("reserve()")]),t._v(" "),r("li",[t._v("sort()")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("若数组中全都Number类型，则可以通过减法优化sort\nlet arr = [1,6,2,1,9,7]\narr.sort((v1,v2)=>(v1-v2)) // [1, 1, 2, 6, 7, 9]\n")])])]),r("ol",{attrs:{start:"8"}},[r("li",[r("p",[t._v("操作方法")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("concat() 合并数组")]),t._v(" "),r("ul",[r("li",[t._v("拷贝一份原数组的副本，将concat对应参数添加至副本数组后面")]),t._v(" "),r("li")])]),t._v(" "),r("li",[r("p",[t._v("slice() 获取数组中的部分元素")]),t._v(" "),r("ul",[r("li",[t._v("参数：\n"),r("ul",[r("li",[t._v("返回数组的开始索引")]),t._v(" "),r("li",[t._v("结束索引（可不填）")])])]),t._v(" "),r("li",[t._v("不影响原数组")]),t._v(" "),r("li",[t._v("返回结果中不包含结束索引对应的元素")])])]),t._v(" "),r("li",[r("p",[t._v("splice()")])])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("  let arr = [1,2,3,4,5,6]\n  // 1. 删除: splice(开始索引, 删除元素数量)\n  arr.splice(0,2); // [1,2]\n  arr; // [3,4,5,6]\n\n  // 2. 插入: splice(开始索引, 0, ...所需添加的元素)\n  arr.splice(2, 0, 8,8,8); // []\n  arr;  // [1, 2, 8, 8, 8, 3, 4, 5, 6]\n\n  // 3. 替换 splice(开始索引, 替换元素数量, ...所需替换的元素)\n  arr.splice(2,2,9,9); // [3, 4]\n  arr; // [1, 2, 9, 9, 5, 6]\n")])])])]),t._v(" "),r("li",[r("p",[t._v("搜索和位置方法")])])]),t._v(" "),r("ul",[r("li",[r("p",[t._v("严格相等")]),t._v(" "),r("ul",[r("li",[t._v("indexOf(需查找的元素，开始索引)\n"),r("ul",[r("li",[t._v("从前往后查找")]),t._v(" "),r("li",[t._v("找到元素则返回元素所在的索引值，未找到则返回-1")])])]),t._v(" "),r("li",[t._v("lastIndexOf(需查找的元素，开始索引)\n"),r("ul",[r("li",[t._v("从后往前找")]),t._v(" "),r("li",[t._v("找到元素则返回元素所在的索引值，未找到则返回-1")]),t._v(" "),r("li",[r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("- let arr = [1,2,3,4,3,2,1];\n- arr.indexOf(3,3); // 4\n- arr.lastIndexOf(3,3); // 2\n")])])])]),t._v(" "),r("li",[r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code")])])])])]),t._v(" "),r("li",[t._v("includes(需查找的元素，开始索引)\n"),r("ul",[r("li",[t._v("ES7新增")]),t._v(" "),r("li",[t._v("表示是否找到元素，找到则返回true，反之则返回false")])])])])]),t._v(" "),r("li",[r("p",[t._v("断言函数")]),t._v(" "),r("ul",[r("li",[t._v("find()")]),t._v(" "),r("li",[t._v("findIndex()")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('  let arr = [\n    {\n      name: "t1",\n      age:28,\n    },\n    {\n      name: "t2",\n      age:8,\n    },\n    {\n      name: "t3",\n      age:18,\n    },\n    {\n      name: "t4",\n      age:8,\n    },\n  ]\n  arr.find((element,index,array)=>element.age<18); // {name: "t2", age: 8}\n  arr.findIndex((element,index,array)=>element.age<18); // 1 \n')])])]),r("p",[t._v("以上两种方法均查找第一个符合期望的元素")])])]),t._v(" "),r("ol",{attrs:{start:"10"}},[r("li",[t._v("迭代方法")])]),t._v(" "),r("ul",[r("li",[t._v("every() 若每个元素均符合条件，则返回true，反之为false")]),t._v(" "),r("li",[t._v("some() 若其一元素符合条件，则返回true，反之为false")]),t._v(" "),r("li",[t._v("filter() 筛选符合条件的元素")]),t._v(" "),r("li",[t._v("forEach() 对数组中的元素进行处理")]),t._v(" "),r("li",[t._v("map() 对数组的每一项进行计算后再返回一个结果数组")])]),t._v(" "),r("ol",{attrs:{start:"11"}},[r("li",[t._v("归并方法")])]),t._v(" "),r("ul",[r("li",[t._v("reduce(上一个归并值，当前项，当前项的索引，数组本身)")]),t._v(" "),r("li",[t._v("reduceRight(上一个归并值，当前项，当前项的索引，数组本身)")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("  let arr = [1,2,3,4,5]\n  let sum = arr.reduce((prev,cur,index,array)=>prev+cur);\n  console.log(sum) // 15\n")])])]),t._v(" "),r("h2",{attrs:{id:"快数组与慢数组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#快数组与慢数组"}},[t._v("#")]),t._v(" 快数组与慢数组")]),t._v(" "),r("p",[t._v("fast: 快速的后备存储结构是 FixedArray ， 并且数组长度 <= elements.length\nslow: 缓慢的后备存储结构是 一个以数字为键的 HashTable 。")]),t._v(" "),r("p",[t._v("HashTable： 散列表（哈希表）\n根据键（key）直接访问在内存存储位置的数据结构。即，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。")]),t._v(" "),r("h3",{attrs:{id:"快数组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#快数组"}},[t._v("#")]),t._v(" 快数组")]),t._v(" "),r("p",[t._v("一种线性的存储方式。数组长度可变，会根据删除和新增来动态调整存储空间的大小。")]),t._v(" "),r("ul",[r("li",[t._v("扩容后，会将数组拷贝到新的内存空间中，扩容后的新容量 = 旧容量 * 1.5 + 16 ；\n当 容量 >= length * 2 + 16 ，则进行收缩容量调整，否则使用holes对象填充未被初始化的位置。")]),t._v(" "),r("li",[t._v("新创建数组时（let arr = new Array(1,2,3)），如果没有设置容量，V8会默认使用 Fast Elements 的模式实现；\n如果要对数组设置容量，但并未进行内部元素的初始化（let arr = new Array(10)），则数组内部存在了数组空洞，就会以 Fast Holey Elements 模式实现。")])]),t._v(" "),r("h3",{attrs:{id:"慢数组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#慢数组"}},[t._v("#")]),t._v(" 慢数组")]),t._v(" "),r("p",[t._v("一种字典的内存形式。不用开辟大块连续的存储空间，节省内存，但维护 HashTable 的成本较高。")]),t._v(" "),r("h3",{attrs:{id:"比较快数组和慢数组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#比较快数组和慢数组"}},[t._v("#")]),t._v(" 比较快数组和慢数组")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("比较")]),t._v(" "),r("th",[t._v("快数组")]),t._v(" "),r("th",[t._v("慢数组")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("存储方式")]),t._v(" "),r("td",[t._v("连续")]),t._v(" "),r("td",[t._v("零散分配")])]),t._v(" "),r("tr",[r("td",[t._v("内存使用")]),t._v(" "),r("td",[t._v("大块连续，可能存在空洞，比较费内存")]),t._v(" "),r("td",[t._v("零散无空洞，比较节省内存")])]),t._v(" "),r("tr",[r("td",[t._v("遍历效率")]),t._v(" "),r("td",[t._v("快")]),t._v(" "),r("td",[t._v("慢")])])])]),t._v(" "),r("p",[t._v("所以两者各有优劣势，快数组是以空间换时间的方式，申请大块连续的内存，提高了查找的效率，而慢数组时以时间换空间，比较省内存，但查找比较费时间。")]),t._v(" "),r("h3",{attrs:{id:"快慢数组之间的切换"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#快慢数组之间的切换"}},[t._v("#")]),t._v(" 快慢数组之间的切换")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://www.html.cn/qa/other/22672.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("数据的存储方式"),r("OutboundLink")],1)]),t._v(" "),r("ul",[r("li",[t._v("顺序")]),t._v(" "),r("li",[t._v("链接")]),t._v(" "),r("li",[t._v("索引")]),t._v(" "),r("li",[t._v("散列")])]),t._v(" "),r("h2",{attrs:{id:"定型数组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#定型数组"}},[t._v("#")]),t._v(" 定型数组")]),t._v(" "),r("p",[t._v("目的：提升向原生库传输数据的效率\n为了解决WebGL的早期版本中，每次WebGL与JS运行期间之间传递数组时，期间花费了较多的转换过程，产生了更多的时间消耗。")]),t._v(" "),r("p",[t._v("定型数组可以直接传给底层图形绘制驱动程序API，也可以直接从底层获取到JS所需的数组。")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("ArrayBuffer")]),t._v(" "),r("ul",[r("li",[t._v("即JS构造函数，也是所有定型数组及视图引用的基本单位")]),t._v(" "),r("li",[t._v("用于在内存中分配特定数量的字节空间，创建后不许更改\n"),r("ul",[r("li",[t._v("区分于 C++ 中的 malloc\n"),r("ul",[r("li",[r("ol",[r("li")])]),t._v(" "),r("li",[r("ol",{attrs:{start:"2"}},[r("li")])]),t._v(" "),r("li",[r("ol",{attrs:{start:"3"}},[r("li")])]),t._v(" "),r("li",[r("ol",{attrs:{start:"4"}},[r("li")])])])])])])])]),t._v(" "),r("li",[r("h2",{attrs:{id:"dataview"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dataview"}},[t._v("#")]),t._v(" DataView")])]),t._v(" "),r("li",[r("p",[t._v("比较几种遍历方法")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("方法")]),t._v(" "),r("th",[t._v("for")]),t._v(" "),r("th",[t._v("forEach")]),t._v(" "),r("th",[t._v("for ... in ...(主要是遍历Object)")]),t._v(" "),r("th",[t._v("for ... of ...")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("return")]),t._v(" "),r("td",[t._v("1")]),t._v(" "),r("td",[t._v("1")]),t._v(" "),r("td",[t._v("0")]),t._v(" "),r("td",[t._v("0")])]),t._v(" "),r("tr",[r("td",[t._v("break")]),t._v(" "),r("td",[t._v("1")]),t._v(" "),r("td",[t._v("0")]),t._v(" "),r("td",[t._v("1")]),t._v(" "),r("td",[t._v("1")])]),t._v(" "),r("tr",[r("td",[t._v("continue")]),t._v(" "),r("td",[t._v("1")]),t._v(" "),r("td",[t._v("0")]),t._v(" "),r("td",[t._v("1")]),t._v(" "),r("td",[t._v("1")])])])])])]),t._v(" "),r("p",[t._v("区分 for ... in ... 和 for ... of ... :")]),t._v(" "),r("ul",[r("li",[t._v("比较几种循环方法\n"),r("table",[r("thead",[r("tr",[r("th",[t._v("方法")]),t._v(" "),r("th",[t._v("map")]),t._v(" "),r("th",[t._v("filter")]),t._v(" "),r("th",[t._v("reduce")]),t._v(" "),r("th",[t._v("every")]),t._v(" "),r("th",[t._v("some")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("返回值")]),t._v(" "),r("td",[t._v("新数组")]),t._v(" "),r("td",[t._v("新数组")]),t._v(" "),r("td",[t._v("新值")]),t._v(" "),r("td",[t._v("true/false")]),t._v(" "),r("td",[t._v("true/false")])])])])])]),t._v(" "),r("h2",{attrs:{id:"特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),r("h3",{attrs:{id:"存储"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#存储"}},[t._v("#")]),t._v(" 存储")]),t._v(" "),r("p",[t._v("连续空间的内存地址且按照顺序存储数据")]),t._v(" "),r("h3",{attrs:{id:"空间效率"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#空间效率"}},[t._v("#")]),t._v(" 空间效率")]),t._v(" "),r("p",[t._v("由于创建数组时，我们需要首先制定数组的容量大小，再根据大小分配内存，因此会导致数组的空间效率不高，经常会有空闲的区域没有得到充分利用。")]),t._v(" "),r("h3",{attrs:{id:"时间效率"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#时间效率"}},[t._v("#")]),t._v(" 时间效率")]),t._v(" "),r("p",[t._v("因为可以凭借数组下标直接访问目标数据（为“随机访问”），所以，访问简单，时间效率高，但添加和删除数据较麻烦。")]),t._v(" "),r("h2",{attrs:{id:"复杂度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#复杂度"}},[t._v("#")]),t._v(" 复杂度")]),t._v(" "),r("p",[t._v("查找时：O(1)\n添加/删除时：O(n)")]),t._v(" "),r("p",[t._v("比较链表和数组：")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th"),t._v(" "),r("th",[t._v("访问")]),t._v(" "),r("th",[t._v("添加")]),t._v(" "),r("th",[t._v("删除")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("链表")]),t._v(" "),r("td",[t._v("慢")]),t._v(" "),r("td",[t._v("快")]),t._v(" "),r("td",[t._v("快")])]),t._v(" "),r("tr",[r("td",[t._v("数组")]),t._v(" "),r("td",[t._v("快")]),t._v(" "),r("td",[t._v("慢")]),t._v(" "),r("td",[t._v("慢")])])])]),t._v(" "),r("h2",{attrs:{id:"算法经验"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#算法经验"}},[t._v("#")]),t._v(" 算法经验")]),t._v(" "),r("p",[t._v("当我们需要解决一个复杂的问题时，一个很有效的办法就是从一个具体的问题入手，通过分析简单具体的例子，试图寻找普遍的规律。")]),t._v(" "),r("h2",{attrs:{id:"参考"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/array-and-string/cuxq3/",target:"_blank",rel:"noopener noreferrer"}},[t._v("leetcode 数组和字符串"),r("OutboundLink")],1),t._v(" "),r("a",{attrs:{href:"https://leetcode-cn.com/problem-list/2cktkvj/",target:"_blank",rel:"noopener noreferrer"}},[t._v("leetcode 算法题自测"),r("OutboundLink")],1),t._v(" "),r("a",{attrs:{href:"https://juejin.cn/post/6844903538175262734",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript 数组遍历方法的对比"),r("OutboundLink")],1),t._v(" "),r("a",{attrs:{href:"https://weread.qq.com/web/reader/1f132a805a61751f1674656k1ff325f02181ff1de7742fc",target:"_blank",rel:"noopener noreferrer"}},[t._v("剑指Offer"),r("OutboundLink")],1),t._v(" "),r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/96959371",target:"_blank",rel:"noopener noreferrer"}},[t._v("探究JS V8引擎下的“数组”底层实现"),r("OutboundLink")],1),t._v(" "),r("a",{attrs:{href:"https://github.com/v8/v8",target:"_blank",rel:"noopener noreferrer"}},[t._v("Chrome V8引擎代码"),r("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=_.exports}}]);