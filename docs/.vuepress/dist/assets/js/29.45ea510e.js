(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{394:function(e,t,n){"use strict";n.r(t);var o=n(45),r=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"react-hooks-源码解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks-源码解析"}},[e._v("#")]),e._v(" React Hooks 源码解析")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("useState做了什么？")]),e._v(" "),n("ol",[n("li",[e._v("useState() 的执行等于 dispatcher.useState(initialState) 这里面引入了一个dispatcher")]),e._v(" "),n("li")])]),e._v(" "),n("li",[n("p",[e._v("函数组件的执行时期是什么时候？\n在调用 "),n("strong",[e._v("renderWithHooks")]),e._v(" 时触发执行")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("初始化")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  renderWithHooks(\n    null,                // current Fiber\n    workInProgress,      // workInProgress Fiber\n    Component,           // 函数组件本身\n    props,               // props\n    context,             // 上下文\n    renderExpirationTime,// 渲染 ExpirationTime\n);\n")])])])]),e._v(" "),n("li",[n("p",[e._v("组件更新\n对于初始化是没有current树的，之后完成一次组件更新后，会把当前workInProgress树赋值给current树。")])])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  renderWithHooks(\n    current,\n    workInProgress,\n    render,\n    nextProps,\n    context,\n    renderExpirationTime,\n);        \n\n")])])]),n("p",[e._v("完整代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  export function renderWithHooks(\n    current,\n    workInProgress,\n    Component,\n    props,\n    secondArg,\n    nextRenderExpirationTime,\n  ) {\n    renderExpirationTime = nextRenderExpirationTime;\n    currentlyRenderingFiber = workInProgress;\n\n    workInProgress.memoizedState = null;\n    workInProgress.updateQueue = null;\n    workInProgress.expirationTime = NoWork;\n\n    ReactCurrentDispatcher.current =\n        current === null || current.memoizedState === null\n          ? HooksDispatcherOnMount\n          : HooksDispatcherOnUpdate;\n\n    let children = Component(props, secondArg);\n\n    if (workInProgress.expirationTime === renderExpirationTime) { \n        // ....这里的逻辑我们先放一放\n    }\n\n    ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n    renderExpirationTime = NoWork;\n    currentlyRenderingFiber = null;\n\n    currentHook = null\n    workInProgressHook = null;\n\n    didScheduleRenderPhaseUpdate = false;\n\n    return children;\n  }\n\n")])])]),n("ul",[n("li",[e._v("current fiber树: 当完成一次渲染之后，会产生一个current树,current会在commit阶段替换成真实的Dom树。")]),e._v(" "),n("li",[e._v("workInProgress fiber树: 即将调和渲染的 fiber 树。再一次新的组件更新过程中，会从current复制一份作为 workInProgress，更新完毕后，将当前的 workInProgress 树赋值给 current 树。")]),e._v(" "),n("li",[e._v("workInProgress.memoizedState: 在class组件中，memoizedState存放state信息，在 function 组件中，memoizedState 在一次调和渲染过程中，以链表的形式存放 hooks 信息。")]),e._v(" "),n("li",[e._v("workInProgress.expirationTime: react 用不同的expirationTime，来确定更新的优先级。")]),e._v(" "),n("li",[e._v("currentHook : current 树上指向当前调度的 hooks 节点。")]),e._v(" "),n("li",[e._v("workInProgressHook : workInProgress 树上指向当前调度 hooks节点。")])]),e._v(" "),n("h3",{attrs:{id:"renderwithhooks-的主要作用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#renderwithhooks-的主要作用"}},[e._v("#")]),e._v(" renderWithHooks 的主要作用：")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("首先置空即将 调 和 渲染 的workInProgress 树的 memoizedState 和 updateQueue 。")]),e._v(" "),n("ul",[n("li",[e._v("为了在函数组件执行过程中，要把新的hooks信息挂载到这两个属性上，然后在组件commit阶段，将workInProgress树替换成current树，替换真实的DOM元素节点，并在current树保存hooks信息。")])])]),e._v(" "),n("li",[n("p",[e._v("根据当前函数组件是否是第一次渲染（current 是否存在 / current树上是否存在 memoizedState 来判断），赋予 ReactCurrentDispatcher.current 不同的 hooks。")]),e._v(" "),n("ul",[n("li",[e._v("第一次渲染组件，是HooksDispatcherOnMount hooks 对象")]),e._v(" "),n("li",[e._v("渲染后，需要更新的函数组件，是HooksDispatcherOnUpdate 对象")])])]),e._v(" "),n("li",[n("p",[e._v("调用 Component(props, secondArg) 执行我们的函数组件")]),e._v(" "),n("ul",[n("li",[e._v("我们写的 hooks 被依次执行，把 hooks 信息依次保存到 workInProgress 树上。")])])]),e._v(" "),n("li",[n("p",[e._v("将 ContextOnlyDispatcher 赋值给 ReactCurrentDispatcher.current ，由于js是单线程的，没有在函数组件中调用的hooks，都是ContextOnlyDispatcher 对象上 hooks")])]),e._v(" "),n("li",[n("p",[e._v("react-hooks就是通过这种函数组件执行赋值不同的hooks对象方式，判断在hooks执行是否在函数组件内部，捕获并抛出异常的。")])]),e._v(" "),n("li",[n("p",[e._v("重新置空一些变量比如currentHook，currentlyRenderingFiber,workInProgressHook等")])])]),e._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[e._v("HooksDispatcherOnMount 首次渲染")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("```\n  const HooksDispatcherOnMount = {\n    useCallback: mountCallback,\n    useEffect: mountEffect,\n    useLayoutEffect: mountLayoutEffect,\n    useMemo: mountMemo,\n    useReducer: mountReducer,\n    useRef: mountRef,\n    useState: mountState,\n  };\n```\n")])])]),n("ol",{attrs:{start:"4"}},[n("li",[e._v("HooksDispatcherOnUpdate 更新组件")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("```\n  const HooksDispatcherOnUpdate = {\n    useCallback: updateCallback,\n    useEffect: updateEffect,\n    useLayoutEffect: updateLayoutEffect,\n    useMemo: updateMemo,\n    useReducer: updateReducer,\n    useRef: updateRef,\n    useState: updateState\n  };\n\n```\n")])])])]),e._v(" "),n("li",[n("p",[e._v("hooks初始化，我们写的hooks会变成什么样子")]),e._v(" "),n("ol",[n("li",[e._v("几种hooks:\n"),n("ol",[n("li",[e._v("useState：负责组件更新")]),e._v(" "),n("li",[e._v("useEffect：负责执行副作用")]),e._v(" "),n("li",[e._v("useRef：负责保存数据")]),e._v(" "),n("li",[e._v("useMemo：负责缓存优化")]),e._v(" "),n("li",[e._v("useCallback")]),e._v(" "),n("li",[e._v("useReducer")]),e._v(" "),n("li",[e._v("useLayoutEffect")])])]),e._v(" "),n("li",[e._v("mountWorkInProgressHook\n在组件初始化的时候,每一次hooks执行该函数(react-reconciler/src/ReactFiberHooks.js -> mountWorkInProgressHook)。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  function mountWorkInProgressHook() {\n    const hook: Hook = {\n      memoizedState: null,  \n      baseState: null,\n      baseQueue: null,\n      queue: null,\n      next: null,\n    };\n    if (workInProgressHook === null) { \n      currentlyRenderingFiber.memoizedState = workInProgressHook = hook;\n    } else {\n      workInProgressHook = workInProgressHook.next = hook;\n    }\n    return workInProgressHook;\n  }\n\n")])])]),n("p",[e._v("首先每次执行一个hooks函数产生一个hook对象，保存当前hook信息,然后将"),n("strong",[e._v("每个hooks以链表形式串联")]),e._v("起来，并赋值给workInProgress的memoizedState。")]),e._v(" "),n("h6",{attrs:{id:"保存的hook信息有哪些"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#保存的hook信息有哪些"}},[e._v("#")]),e._v(" 保存的hook信息有哪些？")]),e._v(" "),n("ul",[n("li",[e._v("memoizedState： useState中保存 state 信息 ｜ useEffect 中 保存着 effect 对象 ｜ useMemo 中 保存的是缓存的值和 deps ｜ useRef 中保存的是 ref 对象。")]),e._v(" "),n("li",[e._v("baseQueue： useState和useReducer中保存最新的更新队列。")]),e._v(" "),n("li",[e._v("baseState： usestate和useReducer的一次更新中，产生的最新state值。")]),e._v(" "),n("li",[e._v("queue： 保存待更新队列 pendingQueue ，更新函数 dispatch 等信息。")]),e._v(" "),n("li",[e._v("next: 指向下一个 hooks对象。")])]),e._v(" "),n("ol",[n("li",[e._v("初始化useState -> mountState")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  function mountState(\n    initialState\n  ){\n    const hook = mountWorkInProgressHook();\n    if (typeof initialState === 'function') {\n      // 如果 useState 第一个参数为函数，执行函数得到state\n      initialState = initialState();\n    }\n    hook.memoizedState = hook.baseState = initialState;\n    const queue = (hook.queue = {\n      pending: null,  // 带更新的\n      dispatch: null, // 负责更新函数\n      lastRenderedReducer: basicStateReducer, //用于得到最新的 state ,\n      lastRenderedState: initialState, // 最后一次得到的 state\n    });\n\n    const dispatch = (queue.dispatch = (dispatchAction.bind( // 负责更新的函数\n      null,\n      currentlyRenderingFiber,\n      queue,\n    )))\n    return [hook.memoizedState, dispatch];\n  }\n")])])]),n("p",[e._v("mountState首先会得到初始化的state，将它赋值给mountWorkInProgressHook产生的hook对象的 memoizedState和baseState属性，然后创建一个queue对象，里面保存了负责更新的信息。")]),e._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[e._v("初始化useEffect -> mountEffect")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  function mountEffect(\n    create,\n    deps,\n  ) {\n    const hook = mountWorkInProgressHook();\n    const nextDeps = deps === undefined ? null : deps;\n    hook.memoizedState = pushEffect(\n      HookHasEffect | hookEffectTag, \n      create, // useEffect 第一次参数，就是副作用函数\n      undefined,\n      nextDeps, // useEffect 第二次参数，deps\n    );\n  }\n")])])]),n("p",[e._v("区分不同场景下的memoizedState：")]),e._v(" "),n("ul",[n("li",[e._v("workInProgress / current 树上的 memoizedState 保存的是当前函数组件每个hooks形成的链表。")]),e._v(" "),n("li",[e._v("每个hooks上的memoizedState 保存了当前hooks信息，不同种类的hooks的memoizedState内容不同")])]),e._v(" "),n("h6",{attrs:{id:"pusheffect-创建effect对象-挂载updatequeue"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pusheffect-创建effect对象-挂载updatequeue"}},[e._v("#")]),e._v(" pushEffect 创建effect对象，挂载updateQueue")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  function pushEffect(tag, create, destroy, deps) {\n    const effect = {\n      tag,\n      create,\n      destroy,\n      deps,\n      next: null,\n    };\n    let componentUpdateQueue = currentlyRenderingFiber.updateQueue\n    if (componentUpdateQueue === null) { // 如果是第一个 useEffect\n      componentUpdateQueue = {  lastEffect: null  }\n      currentlyRenderingFiber.updateQueue = componentUpdateQueue\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {  // 存在多个effect\n      const lastEffect = componentUpdateQueue.lastEffect;\n      if (lastEffect === null) {\n        componentUpdateQueue.lastEffect = effect.next = effect;\n      } else {\n        const firstEffect = lastEffect.next;\n        lastEffect.next = effect;\n        effect.next = firstEffect;\n        componentUpdateQueue.lastEffect = effect;\n      }\n    }\n    return effect;\n  }\n")])])]),n("p",[e._v("首先创建一个 effect ，判断组件如果第一次渲染，那么创建 componentUpdateQueue ，就是workInProgress的updateQueue。然后将effect放入updateQueue中。")]),e._v(" "),n("p",[e._v("effectList:\neffect list 可以理解为是一个存储 effectTag 副作用列表容器。它是由 fiber 节点和指针 nextEffect 构成的单链表结构，这其中还包括第一个节点 firstEffect ，和最后一个节点 lastEffect。\nReact 采用深度优先搜索算法，在 render 阶段遍历 fiber 树时，把每一个有副作用的 fiber 筛选出来，最后构建生成一个只带副作用的 effect list 链表。\n在 commit 阶段，React 拿到 effect list 数据后，通过遍历 effect list，并根据每一个 effect 节点的 effectTag 类型，执行每个effect，从而对相应的 DOM 树执行更改。")]),e._v(" "),n("ol",[n("li",[e._v("初始化useMemo -> mountMemo")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  function mountMemo(nextCreate,deps){\n    const hook = mountWorkInProgressHook();\n    const nextDeps = deps === undefined ? null : deps;\n    const nextValue = nextCreate();\n    hook.memoizedState = [nextValue, nextDeps];\n    return nextValue;\n  } \n")])])]),n("p",[e._v("初始化useMemo，就是创建一个hook，然后执行useMemo的第一个参数,得到需要缓存的值，然后将值和deps记录下来，赋值给当前hook的memoizedState。")]),e._v(" "),n("ol",[n("li",[e._v("初始化useRef -> mountRef")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  function mountRef(initialValue) {\n    const hook = mountWorkInProgressHook();\n    const ref = {current: initialValue};\n    hook.memoizedState = ref;\n    return ref;\n  }\n")])])]),n("p",[e._v("创建一个ref对象， 对象的current 属性来保存初始化的值，最后用memoizedState保存ref。")]),e._v(" "),n("h4",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),n("p",[e._v("在一个函数组件第一次渲染执行上下文过程中，每个react-hooks执行，都会产生一个hook对象，并形成链表结构，绑定在workInProgress的memoizedState属性上，然后react-hooks上的状态，绑定在当前hooks对象的memoizedState属性上。对于effect副作用钩子，会绑定在workInProgress.updateQueue上，等到commit阶段，dom树构建完成，在执行每个 effect 副作用钩子。")])]),e._v(" "),n("li",[n("p",[e._v("hooks更新阶段\n对于一次函数组件更新，当再次执行hooks函数的时候，比如 useState(0) ，首先要从current的hooks中找到与当前workInProgressHook，对应的currentHooks，然后复制一份currentHooks给workInProgressHook,接下来hooks函数执行的时候,把最新的状态更新到workInProgressHook，保证hooks状态不丢失。")])])]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.cn/post/6944863057000529933",target:"_blank",rel:"noopener noreferrer"}},[n("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=r.exports}}]);