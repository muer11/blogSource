<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>佳佳同学の分享</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="积跬步以至千里~">
    
    <link rel="preload" href="/blog/assets/css/0.styles.b3674731.css" as="style"><link rel="preload" href="/blog/assets/js/app.9126ccc7.js" as="script"><link rel="preload" href="/blog/assets/js/2.2e48a36f.js" as="script"><link rel="preload" href="/blog/assets/js/29.45ea510e.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.4a393333.js"><link rel="prefetch" href="/blog/assets/js/11.6beaf23b.js"><link rel="prefetch" href="/blog/assets/js/12.bfed1097.js"><link rel="prefetch" href="/blog/assets/js/13.3994585f.js"><link rel="prefetch" href="/blog/assets/js/14.37eca37d.js"><link rel="prefetch" href="/blog/assets/js/15.06c25806.js"><link rel="prefetch" href="/blog/assets/js/16.a6602734.js"><link rel="prefetch" href="/blog/assets/js/17.9ab66409.js"><link rel="prefetch" href="/blog/assets/js/18.2970fbff.js"><link rel="prefetch" href="/blog/assets/js/19.99859dca.js"><link rel="prefetch" href="/blog/assets/js/20.596f9a52.js"><link rel="prefetch" href="/blog/assets/js/21.1857d7d3.js"><link rel="prefetch" href="/blog/assets/js/22.24e03a13.js"><link rel="prefetch" href="/blog/assets/js/23.54620ff6.js"><link rel="prefetch" href="/blog/assets/js/24.46783050.js"><link rel="prefetch" href="/blog/assets/js/25.0016064d.js"><link rel="prefetch" href="/blog/assets/js/26.6ea97a62.js"><link rel="prefetch" href="/blog/assets/js/27.26d3913c.js"><link rel="prefetch" href="/blog/assets/js/28.1d991302.js"><link rel="prefetch" href="/blog/assets/js/3.12f7257b.js"><link rel="prefetch" href="/blog/assets/js/30.b1e11584.js"><link rel="prefetch" href="/blog/assets/js/4.719e49fe.js"><link rel="prefetch" href="/blog/assets/js/5.0a0ad271.js"><link rel="prefetch" href="/blog/assets/js/6.66b67ff0.js"><link rel="prefetch" href="/blog/assets/js/7.555ff833.js"><link rel="prefetch" href="/blog/assets/js/8.bd8e16b1.js"><link rel="prefetch" href="/blog/assets/js/9.ee673fd1.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.b3674731.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/images/3.jpeg" alt="佳佳同学の分享" class="logo"> <span class="site-name can-hide">佳佳同学の分享</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/home/" class="nav-link router-link-active">
  首页
</a></div><div class="nav-item"><a href="/blog/base/" class="nav-link">
  计算机综合
</a></div><div class="nav-item"><a href="https://github.com/muer11" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/home/" class="nav-link router-link-active">
  首页
</a></div><div class="nav-item"><a href="/blog/base/" class="nav-link">
  计算机综合
</a></div><div class="nav-item"><a href="https://github.com/muer11" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog/home/" class="sidebar-heading clickable router-link-active open"><span>基础知识</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/home/javascript/array.html" class="sidebar-link">数组</a></li><li><a href="/blog/home/javascript/function.html" class="sidebar-link">函数</a></li><li><a href="/blog/home/javascript/object.html" class="sidebar-link">对象</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog/home/test" class="sidebar-heading clickable"><span>进阶</span> <span class="arrow right"></span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工程化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>安全</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机操作系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机组成原理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/base/" class="sidebar-heading clickable"><span>算法</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react-hooks-源码解析"><a href="#react-hooks-源码解析" class="header-anchor">#</a> React Hooks 源码解析</h1> <ol><li><p>useState做了什么？</p> <ol><li>useState() 的执行等于 dispatcher.useState(initialState) 这里面引入了一个dispatcher</li> <li></li></ol></li> <li><p>函数组件的执行时期是什么时候？
在调用 <strong>renderWithHooks</strong> 时触发执行</p> <ol><li><p>初始化</p> <div class="language- extra-class"><pre class="language-text"><code>  renderWithHooks(
    null,                // current Fiber
    workInProgress,      // workInProgress Fiber
    Component,           // 函数组件本身
    props,               // props
    context,             // 上下文
    renderExpirationTime,// 渲染 ExpirationTime
);
</code></pre></div></li> <li><p>组件更新
对于初始化是没有current树的，之后完成一次组件更新后，会把当前workInProgress树赋值给current树。</p></li></ol> <div class="language- extra-class"><pre class="language-text"><code>  renderWithHooks(
    current,
    workInProgress,
    render,
    nextProps,
    context,
    renderExpirationTime,
);        

</code></pre></div><p>完整代码：</p> <div class="language- extra-class"><pre class="language-text"><code>  export function renderWithHooks(
    current,
    workInProgress,
    Component,
    props,
    secondArg,
    nextRenderExpirationTime,
  ) {
    renderExpirationTime = nextRenderExpirationTime;
    currentlyRenderingFiber = workInProgress;

    workInProgress.memoizedState = null;
    workInProgress.updateQueue = null;
    workInProgress.expirationTime = NoWork;

    ReactCurrentDispatcher.current =
        current === null || current.memoizedState === null
          ? HooksDispatcherOnMount
          : HooksDispatcherOnUpdate;

    let children = Component(props, secondArg);

    if (workInProgress.expirationTime === renderExpirationTime) { 
        // ....这里的逻辑我们先放一放
    }

    ReactCurrentDispatcher.current = ContextOnlyDispatcher;

    renderExpirationTime = NoWork;
    currentlyRenderingFiber = null;

    currentHook = null
    workInProgressHook = null;

    didScheduleRenderPhaseUpdate = false;

    return children;
  }

</code></pre></div><ul><li>current fiber树: 当完成一次渲染之后，会产生一个current树,current会在commit阶段替换成真实的Dom树。</li> <li>workInProgress fiber树: 即将调和渲染的 fiber 树。再一次新的组件更新过程中，会从current复制一份作为 workInProgress，更新完毕后，将当前的 workInProgress 树赋值给 current 树。</li> <li>workInProgress.memoizedState: 在class组件中，memoizedState存放state信息，在 function 组件中，memoizedState 在一次调和渲染过程中，以链表的形式存放 hooks 信息。</li> <li>workInProgress.expirationTime: react 用不同的expirationTime，来确定更新的优先级。</li> <li>currentHook : current 树上指向当前调度的 hooks 节点。</li> <li>workInProgressHook : workInProgress 树上指向当前调度 hooks节点。</li></ul> <h3 id="renderwithhooks-的主要作用"><a href="#renderwithhooks-的主要作用" class="header-anchor">#</a> renderWithHooks 的主要作用：</h3> <ul><li><p>首先置空即将 调 和 渲染 的workInProgress 树的 memoizedState 和 updateQueue 。</p> <ul><li>为了在函数组件执行过程中，要把新的hooks信息挂载到这两个属性上，然后在组件commit阶段，将workInProgress树替换成current树，替换真实的DOM元素节点，并在current树保存hooks信息。</li></ul></li> <li><p>根据当前函数组件是否是第一次渲染（current 是否存在 / current树上是否存在 memoizedState 来判断），赋予 ReactCurrentDispatcher.current 不同的 hooks。</p> <ul><li>第一次渲染组件，是HooksDispatcherOnMount hooks 对象</li> <li>渲染后，需要更新的函数组件，是HooksDispatcherOnUpdate 对象</li></ul></li> <li><p>调用 Component(props, secondArg) 执行我们的函数组件</p> <ul><li>我们写的 hooks 被依次执行，把 hooks 信息依次保存到 workInProgress 树上。</li></ul></li> <li><p>将 ContextOnlyDispatcher 赋值给 ReactCurrentDispatcher.current ，由于js是单线程的，没有在函数组件中调用的hooks，都是ContextOnlyDispatcher 对象上 hooks</p></li> <li><p>react-hooks就是通过这种函数组件执行赋值不同的hooks对象方式，判断在hooks执行是否在函数组件内部，捕获并抛出异常的。</p></li> <li><p>重新置空一些变量比如currentHook，currentlyRenderingFiber,workInProgressHook等</p></li></ul> <ol start="3"><li>HooksDispatcherOnMount 首次渲染</li></ol> <div class="language- extra-class"><pre><code>```
  const HooksDispatcherOnMount = {
    useCallback: mountCallback,
    useEffect: mountEffect,
    useLayoutEffect: mountLayoutEffect,
    useMemo: mountMemo,
    useReducer: mountReducer,
    useRef: mountRef,
    useState: mountState,
  };
```
</code></pre></div><ol start="4"><li>HooksDispatcherOnUpdate 更新组件</li></ol> <div class="language- extra-class"><pre><code>```
  const HooksDispatcherOnUpdate = {
    useCallback: updateCallback,
    useEffect: updateEffect,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: updateReducer,
    useRef: updateRef,
    useState: updateState
  };

```
</code></pre></div></li> <li><p>hooks初始化，我们写的hooks会变成什么样子</p> <ol><li>几种hooks:
<ol><li>useState：负责组件更新</li> <li>useEffect：负责执行副作用</li> <li>useRef：负责保存数据</li> <li>useMemo：负责缓存优化</li> <li>useCallback</li> <li>useReducer</li> <li>useLayoutEffect</li></ol></li> <li>mountWorkInProgressHook
在组件初始化的时候,每一次hooks执行该函数(react-reconciler/src/ReactFiberHooks.js -&gt; mountWorkInProgressHook)。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>  function mountWorkInProgressHook() {
    const hook: Hook = {
      memoizedState: null,  
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    if (workInProgressHook === null) { 
      currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
    } else {
      workInProgressHook = workInProgressHook.next = hook;
    }
    return workInProgressHook;
  }

</code></pre></div><p>首先每次执行一个hooks函数产生一个hook对象，保存当前hook信息,然后将<strong>每个hooks以链表形式串联</strong>起来，并赋值给workInProgress的memoizedState。</p> <h6 id="保存的hook信息有哪些"><a href="#保存的hook信息有哪些" class="header-anchor">#</a> 保存的hook信息有哪些？</h6> <ul><li>memoizedState： useState中保存 state 信息 ｜ useEffect 中 保存着 effect 对象 ｜ useMemo 中 保存的是缓存的值和 deps ｜ useRef 中保存的是 ref 对象。</li> <li>baseQueue： useState和useReducer中保存最新的更新队列。</li> <li>baseState： usestate和useReducer的一次更新中，产生的最新state值。</li> <li>queue： 保存待更新队列 pendingQueue ，更新函数 dispatch 等信息。</li> <li>next: 指向下一个 hooks对象。</li></ul> <ol><li>初始化useState -&gt; mountState</li></ol> <div class="language- extra-class"><pre class="language-text"><code>  function mountState(
    initialState
  ){
    const hook = mountWorkInProgressHook();
    if (typeof initialState === 'function') {
      // 如果 useState 第一个参数为函数，执行函数得到state
      initialState = initialState();
    }
    hook.memoizedState = hook.baseState = initialState;
    const queue = (hook.queue = {
      pending: null,  // 带更新的
      dispatch: null, // 负责更新函数
      lastRenderedReducer: basicStateReducer, //用于得到最新的 state ,
      lastRenderedState: initialState, // 最后一次得到的 state
    });

    const dispatch = (queue.dispatch = (dispatchAction.bind( // 负责更新的函数
      null,
      currentlyRenderingFiber,
      queue,
    )))
    return [hook.memoizedState, dispatch];
  }
</code></pre></div><p>mountState首先会得到初始化的state，将它赋值给mountWorkInProgressHook产生的hook对象的 memoizedState和baseState属性，然后创建一个queue对象，里面保存了负责更新的信息。</p> <ol start="2"><li>初始化useEffect -&gt; mountEffect</li></ol> <div class="language- extra-class"><pre class="language-text"><code>  function mountEffect(
    create,
    deps,
  ) {
    const hook = mountWorkInProgressHook();
    const nextDeps = deps === undefined ? null : deps;
    hook.memoizedState = pushEffect(
      HookHasEffect | hookEffectTag, 
      create, // useEffect 第一次参数，就是副作用函数
      undefined,
      nextDeps, // useEffect 第二次参数，deps
    );
  }
</code></pre></div><p>区分不同场景下的memoizedState：</p> <ul><li>workInProgress / current 树上的 memoizedState 保存的是当前函数组件每个hooks形成的链表。</li> <li>每个hooks上的memoizedState 保存了当前hooks信息，不同种类的hooks的memoizedState内容不同</li></ul> <h6 id="pusheffect-创建effect对象-挂载updatequeue"><a href="#pusheffect-创建effect对象-挂载updatequeue" class="header-anchor">#</a> pushEffect 创建effect对象，挂载updateQueue</h6> <div class="language- extra-class"><pre class="language-text"><code>  function pushEffect(tag, create, destroy, deps) {
    const effect = {
      tag,
      create,
      destroy,
      deps,
      next: null,
    };
    let componentUpdateQueue = currentlyRenderingFiber.updateQueue
    if (componentUpdateQueue === null) { // 如果是第一个 useEffect
      componentUpdateQueue = {  lastEffect: null  }
      currentlyRenderingFiber.updateQueue = componentUpdateQueue
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {  // 存在多个effect
      const lastEffect = componentUpdateQueue.lastEffect;
      if (lastEffect === null) {
        componentUpdateQueue.lastEffect = effect.next = effect;
      } else {
        const firstEffect = lastEffect.next;
        lastEffect.next = effect;
        effect.next = firstEffect;
        componentUpdateQueue.lastEffect = effect;
      }
    }
    return effect;
  }
</code></pre></div><p>首先创建一个 effect ，判断组件如果第一次渲染，那么创建 componentUpdateQueue ，就是workInProgress的updateQueue。然后将effect放入updateQueue中。</p> <p>effectList:
effect list 可以理解为是一个存储 effectTag 副作用列表容器。它是由 fiber 节点和指针 nextEffect 构成的单链表结构，这其中还包括第一个节点 firstEffect ，和最后一个节点 lastEffect。
React 采用深度优先搜索算法，在 render 阶段遍历 fiber 树时，把每一个有副作用的 fiber 筛选出来，最后构建生成一个只带副作用的 effect list 链表。
在 commit 阶段，React 拿到 effect list 数据后，通过遍历 effect list，并根据每一个 effect 节点的 effectTag 类型，执行每个effect，从而对相应的 DOM 树执行更改。</p> <ol><li>初始化useMemo -&gt; mountMemo</li></ol> <div class="language- extra-class"><pre class="language-text"><code>  function mountMemo(nextCreate,deps){
    const hook = mountWorkInProgressHook();
    const nextDeps = deps === undefined ? null : deps;
    const nextValue = nextCreate();
    hook.memoizedState = [nextValue, nextDeps];
    return nextValue;
  } 
</code></pre></div><p>初始化useMemo，就是创建一个hook，然后执行useMemo的第一个参数,得到需要缓存的值，然后将值和deps记录下来，赋值给当前hook的memoizedState。</p> <ol><li>初始化useRef -&gt; mountRef</li></ol> <div class="language- extra-class"><pre class="language-text"><code>  function mountRef(initialValue) {
    const hook = mountWorkInProgressHook();
    const ref = {current: initialValue};
    hook.memoizedState = ref;
    return ref;
  }
</code></pre></div><p>创建一个ref对象， 对象的current 属性来保存初始化的值，最后用memoizedState保存ref。</p> <h4 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h4> <p>在一个函数组件第一次渲染执行上下文过程中，每个react-hooks执行，都会产生一个hook对象，并形成链表结构，绑定在workInProgress的memoizedState属性上，然后react-hooks上的状态，绑定在当前hooks对象的memoizedState属性上。对于effect副作用钩子，会绑定在workInProgress.updateQueue上，等到commit阶段，dom树构建完成，在执行每个 effect 副作用钩子。</p></li> <li><p>hooks更新阶段
对于一次函数组件更新，当再次执行hooks函数的时候，比如 useState(0) ，首先要从current的hooks中找到与当前workInProgressHook，对应的currentHooks，然后复制一份currentHooks给workInProgressHook,接下来hooks函数执行的时候,把最新的状态更新到workInProgressHook，保证hooks状态不丢失。</p></li></ol> <p><a href="https://juejin.cn/post/6944863057000529933" target="_blank" rel="noopener noreferrer"><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.9126ccc7.js" defer></script><script src="/blog/assets/js/2.2e48a36f.js" defer></script><script src="/blog/assets/js/29.45ea510e.js" defer></script>
  </body>
</html>
