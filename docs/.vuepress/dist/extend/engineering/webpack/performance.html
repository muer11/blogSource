<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>佳佳同学の分享</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="积跬步以至千里~">
    
    <link rel="preload" href="/blog/assets/css/0.styles.b3674731.css" as="style"><link rel="preload" href="/blog/assets/js/app.9126ccc7.js" as="script"><link rel="preload" href="/blog/assets/js/2.2e48a36f.js" as="script"><link rel="preload" href="/blog/assets/js/14.37eca37d.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.4a393333.js"><link rel="prefetch" href="/blog/assets/js/11.6beaf23b.js"><link rel="prefetch" href="/blog/assets/js/12.bfed1097.js"><link rel="prefetch" href="/blog/assets/js/13.3994585f.js"><link rel="prefetch" href="/blog/assets/js/15.06c25806.js"><link rel="prefetch" href="/blog/assets/js/16.a6602734.js"><link rel="prefetch" href="/blog/assets/js/17.9ab66409.js"><link rel="prefetch" href="/blog/assets/js/18.2970fbff.js"><link rel="prefetch" href="/blog/assets/js/19.99859dca.js"><link rel="prefetch" href="/blog/assets/js/20.596f9a52.js"><link rel="prefetch" href="/blog/assets/js/21.1857d7d3.js"><link rel="prefetch" href="/blog/assets/js/22.24e03a13.js"><link rel="prefetch" href="/blog/assets/js/23.54620ff6.js"><link rel="prefetch" href="/blog/assets/js/24.46783050.js"><link rel="prefetch" href="/blog/assets/js/25.0016064d.js"><link rel="prefetch" href="/blog/assets/js/26.6ea97a62.js"><link rel="prefetch" href="/blog/assets/js/27.26d3913c.js"><link rel="prefetch" href="/blog/assets/js/28.1d991302.js"><link rel="prefetch" href="/blog/assets/js/29.45ea510e.js"><link rel="prefetch" href="/blog/assets/js/3.12f7257b.js"><link rel="prefetch" href="/blog/assets/js/30.b1e11584.js"><link rel="prefetch" href="/blog/assets/js/4.719e49fe.js"><link rel="prefetch" href="/blog/assets/js/5.0a0ad271.js"><link rel="prefetch" href="/blog/assets/js/6.66b67ff0.js"><link rel="prefetch" href="/blog/assets/js/7.555ff833.js"><link rel="prefetch" href="/blog/assets/js/8.bd8e16b1.js"><link rel="prefetch" href="/blog/assets/js/9.ee673fd1.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.b3674731.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/images/3.jpeg" alt="佳佳同学の分享" class="logo"> <span class="site-name can-hide">佳佳同学の分享</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/home/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/base/" class="nav-link">
  计算机综合
</a></div><div class="nav-item"><a href="https://github.com/muer11" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/home/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/base/" class="nav-link">
  计算机综合
</a></div><div class="nav-item"><a href="https://github.com/muer11" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog/home/" class="sidebar-heading clickable open"><span>基础知识</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/home/javascript/array.html" class="sidebar-link">数组</a></li><li><a href="/blog/home/javascript/function.html" class="sidebar-link">函数</a></li><li><a href="/blog/home/javascript/object.html" class="sidebar-link">对象</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog/home/test" class="sidebar-heading clickable"><span>进阶</span> <span class="arrow right"></span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工程化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>安全</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机操作系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机组成原理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/base/" class="sidebar-heading clickable"><span>算法</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="如何实现性能优化"><a href="#如何实现性能优化" class="header-anchor">#</a> 如何实现性能优化？</h1> <p>思路：在什么场景下，遇到了什么性能问题，围绕什么样的性能指标，采取了哪些性能优化手段，最后取得了什么样的结果（性能优化对业务带来的收益是什么？）。</p> <p>性能优化流程：</p> <ol><li><p>性能指标设定：</p> <ol><li>可衡量，就是可以通过代码来度量</li> <li>关注以用户为中心的关键结果和真实体验</li></ol></li> <li><p>确定性能标准</p> <ol><li>两方面：
<ol><li>加载
<ol><li>进入页面时，页面内容（文字、图片）的加载过程是否流畅</li> <li>判断依据：
<ol><li>First contentful paint (<strong>FCP</strong>)： 测量页面开始加载到某一块内容显示在页面上的时间</li> <li>Largest contentful paint (<strong>LCP</strong>)： 测量页面开始加载到最大文本块内容或图片显示在页面中的时间。</li> <li>DomContentLoaded Event：DOM解析完成时间</li> <li>OnLoad Event：页面资源加载完成时间</li> <li>白屏时间 &lt; (300ms ~ 1s)
<strong>从输入内容回车（包括刷新、跳转等方式）后，到页面开始出现第一个字符的时间.</strong> <ol><li>DNS 查询，建立 TCP 连接，发送首个HTTP请求（如果使用HTTPS还要介入 TLS 的验证时间），返回HTML文档，HTML文档 Head 解析完毕
<ol><li>DNS 查询时间长</li> <li>建立 TCP 请求链接太慢</li> <li>服务器处理请求速度太慢</li> <li>客户端下载、解析、渲染时长过长</li> <li>没有做 Gzip 压缩</li> <li>缺乏本地离线化处理</li></ol></li></ol></li> <li>首屏时间 = 白屏时间 + 渲染时间 ( &lt; 1.5s )
<ol><li>秒开率 = 屏时间 &lt; 1s 的概率， 可利用Spark计算</li></ol></li> <li></li></ol></li></ol></li> <li>交互
<ol><li>用户点击网站或 App 的某个功能，页面交互上是否未打断用户操作</li> <li>判断依据：
<ol><li>视觉稳定性指标 <strong>CLS</strong>（ Cumulative layout shift ）
即布局偏移量，它是指页面从一帧切换到另外一帧时，视线中不稳定元素的偏移情况。</li> <li>首次输入延迟 <strong>FID</strong>（ First Input Delay ）&lt; 100ms
测量用户首次与网站进行交互(例如点击一个链接、按钮、js自定义控件)到浏览器真正进行响应的时间。</li> <li>视觉变化率 <strong>PSI</strong>（ Perceptual Speed Index ）&lt; 20%</li></ol></li></ol></li> <li>扩展知识：
<ol><li>（Chrome）浏览器架构：当导航提交完成后，渲染进程开始着手加载资源以及渲染页面。一旦渲染进程“完成”（finished）渲染，它会通过IPC告知浏览器进程（注意这发生在页面上所有帧（frames）的 onload 事件都已经被触发了而且对应的处理函数已经执行完成了的时候），然后UI线程就会停止导航栏上旋转的圈圈。</li> <li>所以如果为了减少进度条的加载时长，则需要减少onLoad时长。</li> <li>使用ChromeDevTool作为基础的性能分析工具:
<ol><li>Network：观察网络资源加载耗时及顺序
<ul><li>需要禁用缓存、启用网络限速（4g/3g） 模拟移动端弱网情况下</li> <li>DOMContentLoaded：分析哪些资源加载时间较长</li> <li>onload
<ul><li>影响因素：
<ul><li>1.JS加载并执行完成时间 -&gt; 对JS进行压缩、拆分处理（HTTP2下）</li> <li>2.（内部或外部的图片、视频等）资源加载完成 -&gt; 优化资源的加载时机</li></ul></li> <li></li> <li><a href="http://eux.baidu.com/blog/fe/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3window.onload" target="_blank" rel="noopener noreferrer">深入理解 window.onload<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></li> <li>Performace：观察页面渲染表现及JS执行情况
<ul><li>PC端模拟手机端可将 CPU 设置为 4x slowdown 或 6x slowdown</li> <li>核心数据：
<ul><li>Web Vitals 中的 FP 、 FCP 、 LCP 、 Layout Shift 核心页面指标 和 Timings 时长</li> <li>Main Long Tasks 长任务数量和时长，找到耗时较长的任务</li></ul></li> <li>结果分析及方案：
<ul><li>页面 LCP 触发时间较晚，且出现多次布局偏移，影响用户体验，需要尽早渲染内容和减少布局偏移</li> <li>页面 Long Tasks 较多，需要对 JS 进行合理拆分和加载，减少 Long Tasks 数量，特别是影响 DCL 和 Onload Event 的 Task</li></ul></li></ul></li> <li>Lighthouse：对网站进行整体评分，找出可优化项
<ol><li>根据检测出来的结果及优化建议进行优化</li></ol></li></ol></li> <li>打包分析：webpack-bundle-analyzer 、rollup-plugin-visualizer等</li></ol></li></ol></li></ol></li> <li><p>收益评估</p></li> <li><p>诊断清单</p></li> <li><p>优化手段</p> <ol><li><p>解决首屏秒开的方案：</p> <ol><li><p>懒加载：</p> <ol><li>即在长页面加载过程时，先加载关键内容，延迟加载非关键内容。</li> <li>实际使用场景：
<ol><li>先根据手机的可视窗口，估算需要多少条数据，超出首屏的内容，可以在页面下拉或者滚动时再发起加载。</li> <li><strong>如何实现图片的懒加载？</strong></li></ol></li> <li>本质是提供首屏后请求非关键内容的能力</li></ol></li> <li><p>缓存：</p> <ol><li>本质是赋予二次访问不需要重复请求的能力</li> <li>在首屏优化方案中，接口缓存和静态资源缓存起到中流砥柱的作用</li> <li>接口缓存：
<ol><li>Native端通过在WebView初始化之前开始请求数据，可节省时间</li></ol></li> <li>静态资源缓存：
<ol><li>强缓存
<ol><li>Cache-Control:max-age=31536000</li> <li>适用于资源长期不变</li></ol></li> <li>协商缓存
<ol><li>Etag + If-none-match</li> <li>适用于资源本身随时会发生改动</li></ol></li></ol></li></ol></li> <li><p>离线化：</p> <ol><li>线上实时变动的资源数据静态化到本地，访问时走的是本地文件的方案。</li> <li>适合首页或者列表页等不需要登录页面的场景，同时能够支持 SEO 功能。</li> <li>Webpack 的 prerender-spa-plugin 来实现预渲染</li> <li><a href="https://segmentfault.com/a/1190000018182165" target="_blank" rel="noopener noreferrer">前端prerender-spa-plugin预渲染<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol></li> <li><p>并行化：</p> <ol><li>前三者是在请求本身上下功夫，想尽办法减少请求或者推迟请求，而并行化则是在请求通道上功夫，解决请求阻塞问题，进而减少首屏时间。</li> <li><strong>HTTP2.0 多路复用</strong></li></ol></li></ol> <p>综上，懒加载解决的是客户端渲染的问题，缓存是请求服务端数据的性能问题，离线化是综合各方面的解决方案，并行化解决的是请求次数的限制问题。</p></li> <li><p>解决白屏的方案：</p> <ol><li>DNS查询优化
<ol><li>DNS查询是浏览器发起请求时，需要将用户输入的域名地址转换为 IP 地址的过程。</li></ol></li></ol> <ul><li>前端处理：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  &lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt; // 开启 DNS 预解析功能
  &lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://s.google.com/&quot; &gt; // 强制对 s.google.com 的域名做预解析
</code></pre></div><ul><li><h2 id="客户端处理"><a href="#客户端处理" class="header-anchor">#</a> 客户端处理：</h2></li></ul> <ol start="2"><li><p>首字符展示</p> <ol><li>骨架屏：在页面数据加载完成前，先给用户展示出页面的大致结构（灰色占位图），告诉用户页面正在渐进式地加载中，然后在渲染出实际页面后，把这个结构替换掉。骨架屏并没有真正减少白屏时间，但是给了用户一个心理预期，让他可以感受到页面上大致有什么内容。</li></ol></li> <li><p>卡顿治理</p> <ol><li>解决步骤：
<ol><li>先定位问题：通过 charles 等工具抓包看接口数据，如果是和接口相关，找后端同学，或使用数据缓存的方式解决；若为前端问题，则主要是以下两种情况：
<ol><li>浏览器的主线程与合成线程调度不合理
1.</li> <li>计算耗时操作</li></ol></li> <li></li></ol></li></ol></li></ol></li> <li><p>webpack 打包优化：</p> <ol><li>关键JS打包优化
<ol><li>Splitchunks 的正确配置（可使用）</li> <li>提取不同页面和组件都有的共同依赖打包到同一个文件中</li></ol></li> <li>公共组件的按需加载
<ol><li>按需加载的内容应该为独立的组件</li> <li><a href="https://ant.design/docs/react/getting-started-cn#%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD" target="_blank" rel="noopener noreferrer">antd babel-plugin-import<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol></li> <li>业务组件的代码拆分 (Code Splitting)
<ol><li><a href="https://zhuanlan.zhihu.com/p/25874892" target="_blank" rel="noopener noreferrer">react-loadable<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>、@loadable/component 等库</li> <li>React.lazy</li></ol></li></ol></li> <li><p>媒体资源懒加载</p> <ol><li>lazysizes库 <code>className=&quot;lazyload&quot;</code></li> <li>加载时序优化：
可onload之后加载图片，但要注意懒加载不能阻塞业务的正常展示，应该做好超时处理、重试等兜底措施</li> <li>大小尺寸优化
<ol><li>CDN图床压缩图片 + 使用 img 标签 srcset/sizes 属性和 picutre 标签实现响应式图片</li> <li>使用URL动态拼接方式构造url请求，根据机型宽度和网络情况，判断当前图片宽度倍数进行调整（如iphone 1x，ipad 2x，弱网0.5x）
<ol><li>比如阿里云图片压缩配置</li></ol></li> <li>注意：实际业务中需要视觉同学参与，评估图片的清晰度是否符合视觉标准，避免反向优化！</li></ol></li> <li>把 iframe 资源延迟到 onLoad 事件之后</li> <li>字体包大小的优化：<a href="https://ecomfe.github.io/fontmin/#app" target="_blank" rel="noopener noreferrer">fontmin<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 压缩字体资源</li></ol></li> <li><p>页面渲染优化</p> <ol><li>直出页面 <a href="https://www.cnblogs.com/123blog/articles/11697450.html" target="_blank" rel="noopener noreferrer">TTFB<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 时间优化</li> <li>页面渲染时间优化
<ol><li>在Sources中找到css对应的Coverage，分析它的解析时间，适当地把首屏未用到的放到之后展示</li></ol></li> <li>页面布局抖动优化
<ol><li>确定直出页面元素出现位置，根据直出数据做好布局</li> <li>页面小图可以通过base64处理，页面解析的时候就会立即展示</li> <li>减少动态内容对页面布局的影响，使用脱离文档流的方式或定好宽高</li></ol></li></ol></li></ol></li> <li><p>性能项目立项</p></li> <li><p>性能实践</p> <ol><li><p>React.lazy + React.Suspense</p> <ol><li>原理是什么？
<a href="https://juejin.cn/post/6844904191853494280#comment" target="_blank" rel="noopener noreferrer">深入理解React：懒加载（lazy）实现原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Suspense可以使组件“等待”某些操作结束后，再进行渲染。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>  import React, { lazy, Suspense } from 'react';
  const OtherComponent = lazy(() =&gt; import('./OtherComponent'));
  const AnotherComponent = lazy(() =&gt; import('./AnotherComponent'));

  function MyComponent() {
    return (
      &lt;div&gt;
        &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
          &lt;section&gt;
            &lt;OtherComponent /&gt;
            &lt;AnotherComponent /&gt;
          &lt;/section&gt;
        &lt;/Suspense&gt;
      &lt;/div&gt;
    );
  }
</code></pre></div></li></ol></li></ol> <p>参考：
<a href="https://juejin.cn/post/6994383328182796295" target="_blank" rel="noopener noreferrer">腾讯企鹅辅导 H5 性能极致优化<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.9126ccc7.js" defer></script><script src="/blog/assets/js/2.2e48a36f.js" defer></script><script src="/blog/assets/js/14.37eca37d.js" defer></script>
  </body>
</html>
